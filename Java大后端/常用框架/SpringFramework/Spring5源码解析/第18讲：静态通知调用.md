# é™æ€é€šçŸ¥è°ƒç”¨
ä»£ç†å¯¹è±¡è°ƒç”¨æµç¨‹å¦‚ä¸‹ï¼ˆä»¥ JDK åŠ¨æ€ä»£ç†å®ç°ä¸ºä¾‹ï¼‰

- ä» ProxyFactory è·å¾— Target å’Œç¯ç»•é€šçŸ¥é“¾ï¼Œæ ¹æ®ä»–ä¿©åˆ›å»º MethodInvocationï¼Œç®€ç§° mi
- é¦–æ¬¡æ‰§è¡Œ mi.proceed() å‘ç°æœ‰ä¸‹ä¸€ä¸ªç¯ç»•é€šçŸ¥ï¼Œè°ƒç”¨å®ƒçš„ invoke(mi)
- è¿›å…¥ç¯ç»•é€šçŸ¥1ï¼Œæ‰§è¡Œå‰å¢å¼ºï¼Œå†æ¬¡è°ƒç”¨ mi.proceed() å‘ç°æœ‰ä¸‹ä¸€ä¸ªç¯ç»•é€šçŸ¥ï¼Œè°ƒç”¨å®ƒçš„ invoke(mi)
- è¿›å…¥ç¯ç»•é€šçŸ¥2ï¼Œæ‰§è¡Œå‰å¢å¼ºï¼Œè°ƒç”¨ mi.proceed() å‘ç°æ²¡æœ‰ç¯ç»•é€šçŸ¥ï¼Œè°ƒç”¨ mi.invokeJoinPoint() æ‰§è¡Œç›®æ ‡æ–¹æ³•
- ç›®æ ‡æ–¹æ³•æ‰§è¡Œç»“æŸï¼Œå°†ç»“æœè¿”å›ç»™ç¯ç»•é€šçŸ¥2ï¼Œæ‰§è¡Œç¯ç»•é€šçŸ¥2 çš„åå¢å¼º
- ç¯ç»•é€šçŸ¥2ç»§ç»­å°†ç»“æœè¿”å›ç»™ç¯ç»•é€šçŸ¥1ï¼Œæ‰§è¡Œç¯ç»•é€šçŸ¥1 çš„åå¢å¼º
- ç¯ç»•é€šçŸ¥1è¿”å›æœ€ç»ˆçš„ç»“æœ

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12600036/1688915029654-c59e8043-c1af-4342-8409-558dd9fda5a0.png#averageHue=%2394bb99&clientId=ubc5cf744-ff80-4&from=paste&height=887&id=ub64c5bf3&originHeight=1330&originWidth=1455&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=68198&status=done&style=none&taskId=u09919918-075d-4c7b-b5f6-370bd7467be&title=&width=970)
å›¾ä¸­ä¸åŒé¢œè‰²å¯¹åº”ä¸€æ¬¡ç¯ç»•é€šçŸ¥æˆ–ç›®æ ‡çš„è°ƒç”¨èµ·å§‹è‡³ç»ˆç»“

##### ä»£ç å‚è€ƒ
```java
package org.springframework.aop.framework;

import org.aopalliance.intercept.MethodInvocation;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Before;
import org.springframework.aop.Advisor;
import org.springframework.aop.aspectj.*;
import org.springframework.aop.interceptor.ExposeInvocationInterceptor;
import org.springframework.aop.support.DefaultPointcutAdvisor;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class A18 {

    static class Aspect {
        @Before("execution(* foo())")
        public void before1() {
            System.out.println("before1");
        }

        @Before("execution(* foo())")
        public void before2() {
            System.out.println("before2");
        }

        public void after() {
            System.out.println("after");
        }

        @AfterReturning("execution(* foo())")
        public void afterReturning() {
            System.out.println("afterReturning");
        }

        @AfterThrowing("execution(* foo())")
        public void afterThrowing(Exception e) {
            System.out.println("afterThrowing " + e.getMessage());
        }

        @Around("execution(* foo())")
        public Object around(ProceedingJoinPoint pjp) throws Throwable {
            try {
                System.out.println("around...before");
                return pjp.proceed();
            } finally {
                System.out.println("around...after");
            }
        }
    }

    static class Target {
        public void foo() {
            System.out.println("target foo");
        }
    }

    @SuppressWarnings("all")
    public static void main(String[] args) throws Throwable {

        AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect());
        // 1. é«˜çº§åˆ‡é¢è½¬ä½çº§åˆ‡é¢ç±»
        List<Advisor> list = new ArrayList<>();
        for (Method method : Aspect.class.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Before.class)) {
                // è§£æåˆ‡ç‚¹
                String expression = method.getAnnotation(Before.class).value();
                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
                pointcut.setExpression(expression);
                // é€šçŸ¥ç±»
                AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory);
                // åˆ‡é¢
                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);
                list.add(advisor);
            } else if (method.isAnnotationPresent(AfterReturning.class)) {
                // è§£æåˆ‡ç‚¹
                String expression = method.getAnnotation(AfterReturning.class).value();
                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
                pointcut.setExpression(expression);
                // é€šçŸ¥ç±»
                AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice(method, pointcut, factory);
                // åˆ‡é¢
                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);
                list.add(advisor);
            } else if (method.isAnnotationPresent(Around.class)) {
                // è§£æåˆ‡ç‚¹
                String expression = method.getAnnotation(Around.class).value();
                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
                pointcut.setExpression(expression);
                // é€šçŸ¥ç±»
                AspectJAroundAdvice advice = new AspectJAroundAdvice(method, pointcut, factory);
                // åˆ‡é¢
                Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice);
                list.add(advisor);
            }
        }
        for (Advisor advisor : list) {
            System.out.println(advisor);
        }

        /*
            @Before å‰ç½®é€šçŸ¥ä¼šè¢«è½¬æ¢ä¸ºä¸‹é¢åŸå§‹çš„ AspectJMethodBeforeAdvice å½¢å¼, è¯¥å¯¹è±¡åŒ…å«äº†å¦‚ä¸‹ä¿¡æ¯
                a. é€šçŸ¥ä»£ç ä»å“ªå„¿æ¥
                b. åˆ‡ç‚¹æ˜¯ä»€ä¹ˆ
                c. é€šçŸ¥å¯¹è±¡å¦‚ä½•åˆ›å»º, æœ¬ä¾‹å…±ç”¨åŒä¸€ä¸ª Aspect å¯¹è±¡
            ç±»ä¼¼çš„é€šçŸ¥è¿˜æœ‰
                1. AspectJAroundAdvice (ç¯ç»•é€šçŸ¥)
                2. AspectJAfterReturningAdvice
                3. AspectJAfterThrowingAdvice (ç¯ç»•é€šçŸ¥)
                4. AspectJAfterAdvice (ç¯ç»•é€šçŸ¥)
         */

        // 2. é€šçŸ¥ç»Ÿä¸€è½¬æ¢ä¸ºç¯ç»•é€šçŸ¥ MethodInterceptor
        /*

            å…¶å®æ— è®º ProxyFactory åŸºäºå“ªç§æ–¹å¼åˆ›å»ºä»£ç†, æœ€åå¹²æ´»(è°ƒç”¨ advice)çš„æ˜¯ä¸€ä¸ª MethodInvocation å¯¹è±¡
                a. å› ä¸º advisor æœ‰å¤šä¸ª, ä¸”ä¸€ä¸ªå¥—ä¸€ä¸ªè°ƒç”¨, å› æ­¤éœ€è¦ä¸€ä¸ªè°ƒç”¨é“¾å¯¹è±¡, å³ MethodInvocation
                b. MethodInvocation è¦çŸ¥é“ advice æœ‰å“ªäº›, è¿˜è¦çŸ¥é“ç›®æ ‡, è°ƒç”¨æ¬¡åºå¦‚ä¸‹

                å°† MethodInvocation æ”¾å…¥å½“å‰çº¿ç¨‹
                    |-> before1 ----------------------------------- ä»å½“å‰çº¿ç¨‹è·å– MethodInvocation
                    |                                             |
                    |   |-> before2 --------------------          | ä»å½“å‰çº¿ç¨‹è·å– MethodInvocation
                    |   |                              |          |
                    |   |   |-> target ------ ç›®æ ‡   advice2    advice1
                    |   |                              |          |
                    |   |-> after2 ---------------------          |
                    |                                             |
                    |-> after1 ------------------------------------
                c. ä»ä¸Šå›¾çœ‹å‡º, ç¯ç»•é€šçŸ¥æ‰é€‚åˆä½œä¸º advice, å› æ­¤å…¶ä»– beforeã€afterReturning éƒ½ä¼šè¢«è½¬æ¢æˆç¯ç»•é€šçŸ¥
                d. ç»Ÿä¸€è½¬æ¢ä¸ºç¯ç»•é€šçŸ¥, ä½“ç°çš„æ˜¯è®¾è®¡æ¨¡å¼ä¸­çš„é€‚é…å™¨æ¨¡å¼
                    - å¯¹å¤–æ˜¯ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨è¦åŒºåˆ† beforeã€afterReturning
                    - å¯¹å†…ç»Ÿä¸€éƒ½æ˜¯ç¯ç»•é€šçŸ¥, ç»Ÿä¸€ç”¨ MethodInterceptor è¡¨ç¤º

            æ­¤æ­¥è·å–æ‰€æœ‰æ‰§è¡Œæ—¶éœ€è¦çš„ advice (é™æ€)
                a. å³ç»Ÿä¸€è½¬æ¢ä¸º MethodInterceptor ç¯ç»•é€šçŸ¥, è¿™ä½“ç°åœ¨æ–¹æ³•åä¸­çš„ Interceptors ä¸Š
                b. é€‚é…å¦‚ä¸‹
                  - MethodBeforeAdviceAdapter å°† @Before AspectJMethodBeforeAdvice é€‚é…ä¸º MethodBeforeAdviceInterceptor
                  - AfterReturningAdviceAdapter å°† @AfterReturning AspectJAfterReturningAdvice é€‚é…ä¸º AfterReturningAdviceInterceptor
         */
        Target target = new Target();
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.setTarget(target);
        proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE); // å‡†å¤‡æŠŠ MethodInvocation æ”¾å…¥å½“å‰çº¿ç¨‹
        proxyFactory.addAdvisors(list);

        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        List<Object> methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod("foo"), Target.class);
        for (Object o : methodInterceptorList) {
            System.out.println(o);
        }

        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        // 3. åˆ›å»ºå¹¶æ‰§è¡Œè°ƒç”¨é“¾ (ç¯ç»•é€šçŸ¥s + ç›®æ ‡)
        MethodInvocation methodInvocation = new ReflectiveMethodInvocation(
                null, target, Target.class.getMethod("foo"), new Object[0], Target.class, methodInterceptorList
        );
        methodInvocation.proceed();



        /*
            å­¦åˆ°äº†ä»€ä¹ˆ
                a. æ— å‚æ•°ç»‘å®šçš„é€šçŸ¥å¦‚ä½•è¢«è°ƒç”¨
                b. MethodInvocation ç¼–ç¨‹æŠ€å·§: æ‹¦æˆªå™¨ã€è¿‡æ»¤å™¨ç­‰ç­‰å®ç°éƒ½ä¸æ­¤ç±»ä¼¼
                c. é€‚é…å™¨æ¨¡å¼åœ¨ Spring ä¸­çš„ä½“ç°
         */

    }
}

```
# æ”¶è·ğŸ’¡

ä»£ç†æ–¹æ³•æ‰§è¡Œæ—¶ä¼šåšå¦‚ä¸‹å·¥ä½œ

1. é€šè¿‡ proxyFactory çš„ getInterceptorsAndDynamicInterceptionAdvice() å°†å…¶ä»–é€šçŸ¥ç»Ÿä¸€è½¬æ¢ä¸º MethodInterceptor ç¯ç»•é€šçŸ¥ 
   - MethodBeforeAdviceAdapter å°† [@Before ](/Before ) AspectJMethodBeforeAdvice é€‚é…ä¸º MethodBeforeAdviceInterceptor 
   - AfterReturningAdviceAdapter å°† [@AfterReturning ](/AfterReturning ) AspectJAfterReturningAdvice é€‚é…ä¸º AfterReturningAdviceInterceptor 
   - è¿™ä½“ç°çš„æ˜¯é€‚é…å™¨è®¾è®¡æ¨¡å¼
2. æ‰€è°“é™æ€é€šçŸ¥ï¼Œä½“ç°åœ¨ä¸Šé¢æ–¹æ³•çš„ Interceptors éƒ¨åˆ†ï¼Œè¿™äº›é€šçŸ¥è°ƒç”¨æ—¶æ— éœ€å†æ¬¡æ£€æŸ¥åˆ‡ç‚¹ï¼Œç›´æ¥è°ƒç”¨å³å¯
3. ç»“åˆç›®æ ‡ä¸ç¯ç»•é€šçŸ¥é“¾ï¼Œåˆ›å»º MethodInvocation å¯¹è±¡ï¼Œé€šè¿‡å®ƒå®Œæˆæ•´ä¸ªè°ƒç”¨
# æ¨¡æ‹Ÿ MethodInvocation
```java
package org.springframework.aop.framework;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
import java.util.List;

/*
    æ¨¡æ‹Ÿè°ƒç”¨é“¾è¿‡ç¨‹, æ˜¯ä¸€ä¸ªç®€å•çš„é€’å½’è¿‡ç¨‹
        1. proceed() æ–¹æ³•è°ƒç”¨é“¾ä¸­ä¸‹ä¸€ä¸ªç¯ç»•é€šçŸ¥
        2. æ¯ä¸ªç¯ç»•é€šçŸ¥å†…éƒ¨ç»§ç»­è°ƒç”¨ proceed()
        3. è°ƒç”¨åˆ°æ²¡æœ‰æ›´å¤šé€šçŸ¥äº†, å°±è°ƒç”¨ç›®æ ‡æ–¹æ³•
 */
public class A18_1 {

    static class Target {
        public void foo() {
            System.out.println("Target.foo()");
        }
    }

    static class Advice1 implements MethodInterceptor {
        public Object invoke(MethodInvocation invocation) throws Throwable {
            System.out.println("Advice1.before()");
            Object result = invocation.proceed();// è°ƒç”¨ä¸‹ä¸€ä¸ªé€šçŸ¥æˆ–ç›®æ ‡
            System.out.println("Advice1.after()");
            return result;
        }
    }

    static class Advice2 implements MethodInterceptor {
        public Object invoke(MethodInvocation invocation) throws Throwable {
            System.out.println("Advice2.before()");
            Object result = invocation.proceed();// è°ƒç”¨ä¸‹ä¸€ä¸ªé€šçŸ¥æˆ–ç›®æ ‡
            System.out.println("Advice2.after()");
            return result;
        }
    }


    static class MyInvocation implements MethodInvocation {
        private Object target;  // 1
        private Method method;
        private Object[] args;
        List<MethodInterceptor> methodInterceptorList; // 2
        private int count = 1; // è°ƒç”¨æ¬¡æ•°

        public MyInvocation(Object target, Method method, Object[] args, List<MethodInterceptor> methodInterceptorList) {
            this.target = target;
            this.method = method;
            this.args = args;
            this.methodInterceptorList = methodInterceptorList;
        }

        @Override
        public Method getMethod() {
            return method;
        }

        @Override
        public Object[] getArguments() {
            return args;
        }

        @Override
        public Object proceed() throws Throwable { // è°ƒç”¨æ¯ä¸€ä¸ªç¯ç»•é€šçŸ¥, è°ƒç”¨ç›®æ ‡
            if (count > methodInterceptorList.size()) {
                // è°ƒç”¨ç›®æ ‡ï¼Œ è¿”å›å¹¶ç»“æŸé€’å½’
                return method.invoke(target, args);
            }
            // é€ä¸€è°ƒç”¨é€šçŸ¥, count + 1
            MethodInterceptor methodInterceptor = methodInterceptorList.get(count++ - 1);
            return methodInterceptor.invoke(this);
        }

        @Override
        public Object getThis() {
            return target;
        }

        @Override
        public AccessibleObject getStaticPart() {
            return method;
        }
    }

    public static void main(String[] args) throws Throwable {
        Target target = new Target();
        List<MethodInterceptor> list = List.of(
                new Advice1(),
                new Advice2()
        );
        MyInvocation invocation = new MyInvocation(target, Target.class.getMethod("foo"), new Object[0], list);
        invocation.proceed();
    }
}

```
